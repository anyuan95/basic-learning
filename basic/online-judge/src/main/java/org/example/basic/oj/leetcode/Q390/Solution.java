package org.example.basic.oj.leetcode.Q390;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

class Solution {
    /**
     * 开始思考
     *
     * 第一次删除，把所有下标是奇数的都删除了
     * （无论n是奇数还是偶数，经过第一次清理，剩下的一定都是原本偶数位置的数）
     * 第二次删除，分为两种情况考虑：（只会有这两种情况）
     * - 最后一个数是4k，则本次清理会把所有4的倍数全部清理掉
     * - 最后一个数是4k+2，则本次清理会把所有比4的倍数多2的数全都清理掉
     *
     *
     * 换个思路试试，
     * 无论如何，最后一定只会清理log2n（向下取整）次
     * 假设一共会进行m次清理操作
     * 反过来考虑，如果要x值在最后留下，则它：
     * 在第m次清理时x一定是在位置2
     * 在第m-1次清理时x一定是在位置3
     *
     * 倒数第奇数次清理时可以有2n或2n+1个数，偶数次不行，会影响结果
     *
     *
     * 所以实际上可以倒推，
     * 要让最后结果为x，那么第二次要剩下
     *
     *
     *
     * 再思考，实际上，如果倒着删除的时候，剩余的元素数量是奇数个，那实际上和正着删除是一样的效果
     *
     *
     *
     * 实际上只要推出公式即可
     * 假设：对于x个数组成的数列，正着处理最终得到的是f(x)，反着处理最终得到的是g(x)
     * 1.因为fx和gx在[1,i]上有对称性，所以最终的结果也有对称性，有fx+gx=x+1
     * 2.假设对1-n进行一次正序处理，得到新的数列2,4,6,8...n/2。将新得到的数列重新从1开始编号，那么对新数列再进行反着处理，就应该得到g(n/2向下取整)。
     *  由于进入g的数列实际上是整体缩小了一半的，实际上的值应该是g(n/2向下取整)*2。所以可得f(x)=g(x/2向下取整)*2
     * 最后将上面两个公式进行整理，消掉gx，就能得到f(x)=2*(n/2+1-f(n/2))
     *
     * @param n
     * @return
     */
    public int lastRemaining(int n) {
        return n == 1 ? 1 : 2 * (n / 2 + 1 - lastRemaining(n / 2));
    }

}
