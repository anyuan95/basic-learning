package org.example.basic.oj.zuo.greedy;

/**
 * 分金问题（金条分割的最小代价）
 * <p>
 * 给定一个数组，现要将一根金条切分为数组中的每个项的长度。
 * 切分操作是有代价的，代价为当前要切分的金条的长度。
 * 求切分成数组中各元素长度时，需要的最小代价。
 * <p>
 * 关联问题：哈夫曼树
 *
 * @author anyuan
 * @since 2021-08-13 18:05
 */
class LessMoneySplitGold {


    /**
     * 输入:正数数组costs、正数数组profits、正数K、正数M
     * costs[i]表示i号项目的花费
     * profits[i]表示i号项目在扣除花费之后还能挣到的钱(利润)K表示你只能串行的最多做k个项目
     * M表示你初始的资金
     * 说明:每做完一个项目，马上获得的收益，可以支持你去做下一个项目。不能并行的做项目。
     * 输出:你最后获得的最大钱数。
     */


    /**
     * 解法：
     * 将所有元素放到小根堆中，每次取出堆顶最小的两个元素，进行相加，将结果放回小根堆中。
     * 以此往复，直到堆空为止。
     * <p>
     * <p>
     * 所有[重新放入堆中]的元素的和就是目标值。
     * 最佳切分方式就是该小根堆的结构。
     * <p>
     * 证明见哈夫曼树。
     *
     * @param pieces
     * @return
     */

    private int lessMoneySplitGold(int[] pieces) {
        return 0;
    }
}
