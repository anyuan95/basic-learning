package org.example.basic.oj.leetcode.Q335;

/**
 * @author anyuan
 * @date 2021-10-29 18:25
 */
class Solution_no {
    /**
     * 思路：给定的dist数组是方向不断逆时针旋转的
     * 所以实际上所有的路径都一定是与x轴或y轴平行的
     * 所以只需要保存两个数组，分别存与x轴平行的线和与y轴平行的线（横或纵坐标、线段的最小&最大纵或横坐标）
     *
     * 应该有能优化的方式
     * 如果这个图形不会相交，那一定是从中间向外发散的（从中间开始一层层往外转圈）
     * ！！不可能是从外向内收缩的（从最外层开始一层层向里面转圈），因为最后一次转向后是继续前进的射线
     * 所以考虑实际的几何情况，只有上述的一种情况（向外发散）会满足条件
     *
     *
     * 继续将情况细分，只要转向后的射线（或线段）在图形的最外侧，就不会相交。
     * 易证得这是充分必要条件。
     *
     * 继续细分其他情况：
     * 题目给定每次转向后的前进距离最小是1，就说明不存在向反方向转的情况。
     * 所以可以划定边界情况：
     * - 如果只有一个方向，那就是一条射线，一定不会相交
     * - 如果有两个方向，那就是组成了一个直角，除了直角所在的点，这两条射线不会再有其他交点
     * - 如果有三个方向，那就是组成了一个C型，第一次的方向和第三次的方向一定是平行的，一定不会相交
     * - 如果有四个方向，那就是组成了一个矩形，是否相交就取决于第三条边是否比第一条短，如果短或等长就相交
     * 以此类推：
     * - 如果有五个方向（前4个线段已经不相交了），那第五个一定不会相交
     * - 如果有六个方向（~~~~~~~~~~~~~~~~~~），是否相交就取决于第五条边是否比第三条短，如果短或等长就相交
     * - 如果有七个方向（~~），是否相交就取决于第六条边是否比第四条短，如果短或等长就相交
     *
     *
     * 1 <= distance.length <= 105
     * 1 <= distance[i] <= 105
     *
     * @param distance
     * @return
     */
    public boolean isSelfCrossing(int[] distance) {
        final int n = distance.length;
        if (n < 4) {
            // 只有1、2、3条边时一定不会相交
            return false;
        }
        for (int i = 3; i < n; i++) {
            // 上一条边 和 上上上一条边 比，如果前者短于或等于后者 就一定相交
            if (distance[i - 1] <= distance[i - 3]) {
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) {
        final Solution_no solution = new Solution_no();
        System.out.println(solution.isSelfCrossing(new int[]{3, 3, 4, 2, 2}));
    }
}
